class Solution {
  /*
      我們考慮如果先把個子高的排好序，那麼在任何位置插入資料都不會對已經排好序的陣列造成影響。
      與此同時，我們已經知道了個子高的排序，那麼當新的資料到的時候，我們要確定它的位置也很簡單，
      因為現在的所有資料都比他高，所以只要根據他的第二個數字確定他的位置即可。
      
      先對已有的陣列進行排序。按照高度降序排列，如果高度一樣，按照k的值升序排列。
      這樣比如一開始[7，0] [7，1] [7，2]就會排好，然後比如說後面有一個[6，1]， 
      說明只有一個大於或等於它，又因為比6大的已經全部取出。
      所以把它放在位置1，這樣就變成[7，0] [6，1] [7，1] [7，2].然後比如又有一個[5，0].就放在位置0，
      以此類推。

      即對於案列。首先排序成：

      [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]
      
      再逐個根據k值插入相對應位置
      [[7,0]] insert [7,0] at index 0
      [[7,0],[7,1]] insert [7,1] at index 1
      [[7,0],[6,1],[7,1]] insert [6,1] at index 1
      [[5,0],[7,0],[6,1],[7,1]]
      [[5,0],[7,0],[5,2],[6,1],[7,1]]
      [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

  */
  public int[][] reconstructQueue(int[][] people) {
      Arrays.sort(people, (a, b) -> {
          if (a[0] == b[0]) {
              return a[1] - b[1];
          }
          return b[0] - a[0];
      });
      
      List<int[]> list = new ArrayList<>();
      for (int[] p: people) {
          list.add(p[1], p);
      }
      
      int[][] res = new int[people.length][2];
      
      for (int i = 0; i < list.size(); i++) {
          res[i] = list.get(i);
      }
      
      return res; // return res.toArray(new int[0][0]);
  }
}
